name: Release

on:
  push:
    branches: [main]
  schedule:
    - cron: '0 9 * * *'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (patch, minor, major)'
        required: false
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check-changes.outputs.should_release }}
      version: ${{ steps.version.outputs.version }}
      pr_number: ${{ steps.find-pr.outputs.pr_number }}
      pr_exists: ${{ steps.find-pr.outputs.pr_exists }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Get latest release
        id: latest-release
        run: |
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT
          echo "Latest tag: $latest_tag"

      - name: Check for changes since last release
        id: check-changes
        run: |
          latest_tag="${{ steps.latest-release.outputs.latest_tag }}"
          
          if [ "$latest_tag" = "v0.0.0" ]; then
            commits_since_release=$(git rev-list --count HEAD)
          else
            commits_since_release=$(git rev-list --count ${latest_tag}..HEAD)
          fi
          
          echo "commits_since_release=$commits_since_release"
          
          if [ "$commits_since_release" -gt 0 ]; then
            if [ "$latest_tag" = "v0.0.0" ]; then
              significant_changes=$(git log --oneline --grep="^feat\|^fix\|^refactor\|^perf\|BREAKING" HEAD || echo "")
            else
              significant_changes=$(git log --oneline --grep="^feat\|^fix\|^refactor\|^perf\|BREAKING" ${latest_tag}..HEAD || echo "")
            fi
          
            if [ -n "$significant_changes" ] || [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
              echo "should_release=true" >> $GITHUB_OUTPUT
              echo "Should release: true"
            else
              echo "should_release=false" >> $GITHUB_OUTPUT
              echo "Should release: false (no significant changes)"
            fi
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "Should release: false (no commits since last release)"
          fi

      - name: Find existing release PR
        id: find-pr
        run: |
          pr_number=$(gh pr list --state open --label "release" --json number --jq '.[0].number // empty')
          if [ -n "$pr_number" ]; then
            echo "pr_exists=true" >> $GITHUB_OUTPUT
            echo "pr_number=$pr_number" >> $GITHUB_OUTPUT
            echo "Found existing release PR: #$pr_number"
          else
            echo "pr_exists=false" >> $GITHUB_OUTPUT
            echo "No existing release PR found"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine next version
        id: version
        if: steps.check-changes.outputs.should_release == 'true'
        run: |
          latest_tag="${{ steps.latest-release.outputs.latest_tag }}"
          current_version=${latest_tag#v}
          
          if [ "$current_version" = "0.0.0" ]; then
            current_version="1.0.0"
          fi
          
          IFS='.' read -r major minor patch <<< "$current_version"
          
          release_type="${{ github.event.inputs.release_type }}"
          
          if [ -z "$release_type" ] || [ "$release_type" = "patch" ]; then
            if [ "$latest_tag" = "v0.0.0" ]; then
              commits_to_check=$(git log --oneline HEAD)
            else
              commits_to_check=$(git log --oneline ${latest_tag}..HEAD)
            fi
          
            if echo "$commits_to_check" | grep -q "BREAKING\|^feat!"; then
              release_type="major"
            elif echo "$commits_to_check" | grep -q "^feat"; then
              release_type="minor"
            else
              release_type="patch"
            fi
          fi
          
          case $release_type in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac
          
          new_version="$major.$minor.$patch"
          echo "version=$new_version" >> $GITHUB_OUTPUT
          echo "release_type=$release_type" >> $GITHUB_OUTPUT
          echo "New version: $new_version (type: $release_type)"

  create-or-update-release-pr:
    needs: prepare-release
    if: needs.prepare-release.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create or update release branch
        run: |
          version="${{ needs.prepare-release.outputs.version }}"
          branch_name="release/v$version"
          
          if git show-ref --verify --quiet refs/heads/$branch_name; then
            echo "Branch $branch_name already exists, checking out and updating"
            git checkout $branch_name
            git rebase main
          else
            echo "Creating new branch $branch_name"
            git checkout -b $branch_name
          fi
          
          echo "branch_name=$branch_name" >> $GITHUB_ENV

      - name: Update version in types.go
        run: |
          version="${{ needs.prepare-release.outputs.version }}"
          sed -i "s/const Version = \".*\"/const Version = \"$version\"/" types.go
          grep "const Version" types.go

      - name: Generate changelog
        id: changelog
        run: |
          version="${{ needs.prepare-release.outputs.version }}"
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          echo "# Changelog for v$version" > CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          echo "## What's Changed" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          
          if [ -n "$latest_tag" ]; then
            commits=$(git log --oneline --pretty=format:"- %s" ${latest_tag}..HEAD)
          else
            commits=$(git log --oneline --pretty=format:"- %s" HEAD)
          fi
          
          echo "### Features" >> CHANGELOG_TEMP.md
          echo "$commits" | grep -E "^- feat" || echo "- No new features" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          
          echo "### Bug Fixes" >> CHANGELOG_TEMP.md
          echo "$commits" | grep -E "^- fix" || echo "- No bug fixes" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          
          echo "### Other Changes" >> CHANGELOG_TEMP.md
          echo "$commits" | grep -vE "^- (feat|fix)" || echo "- No other changes" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          
          # Keep a copy for PR body
          cp CHANGELOG_TEMP.md CHANGELOG_FOR_PR.md
          
          if [ -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG_NEW.md
            echo "" >> CHANGELOG_NEW.md
            cat CHANGELOG_TEMP.md >> CHANGELOG_NEW.md
            echo "" >> CHANGELOG_NEW.md
            tail -n +2 CHANGELOG.md >> CHANGELOG_NEW.md
            mv CHANGELOG_NEW.md CHANGELOG.md
          else
            mv CHANGELOG_TEMP.md CHANGELOG.md
          fi

      - name: Update go.mod if needed
        run: |
          if grep -q "// v" go.mod; then
            version="${{ needs.prepare-release.outputs.version }}"
            sed -i "s|// v.*|// v$version|" go.mod
          fi

      - name: Run tests
        run: |
          go mod download
          go test ./...

      - name: Commit changes
        run: |
          version="${{ needs.prepare-release.outputs.version }}"
          
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: prepare release v$version"
            git push origin ${{ env.branch_name }}
          fi

      - name: Ensure release label exists
        run: |
          if ! gh label list --search "release" --limit 1 | grep -q "release"; then
            echo "Creating 'release' label..."
            gh label create "release" --description "Automated release PR" --color "0e8a16"
          else
            echo "Release label already exists"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create or update release PR
        run: |
          version="${{ needs.prepare-release.outputs.version }}"
          pr_exists="${{ needs.prepare-release.outputs.pr_exists }}"
          pr_number="${{ needs.prepare-release.outputs.pr_number }}"
          
          pr_title="Release v$version"
          
          # Create PR body directly
          echo "## Release v$version" > pr_body.txt
          echo "" >> pr_body.txt
          echo "This is an automated release PR." >> pr_body.txt
          echo "" >> pr_body.txt
          
          # Add changelog if exists
          if [ -f CHANGELOG_TEMP.md ]; then
            cat CHANGELOG_TEMP.md >> pr_body.txt
          fi
          
          echo "" >> pr_body.txt
          echo "---" >> pr_body.txt
          echo "" >> pr_body.txt
          echo "**Release Checklist:**" >> pr_body.txt
          echo "- [x] Version updated in types.go" >> pr_body.txt
          echo "- [x] Changelog generated" >> pr_body.txt
          echo "- [x] Tests passing" >> pr_body.txt
          echo "- [ ] Ready to merge and release" >> pr_body.txt
          echo "" >> pr_body.txt
          echo "Once this PR is merged, a new release will be automatically created." >> pr_body.txt
          
          if [ "$pr_exists" = "true" ]; then
            echo "Updating existing release PR #$pr_number"
            gh pr edit $pr_number \
              --title "$pr_title" \
              --body-file pr_body.txt
          else
            echo "Creating new release PR"
            pr_url=$(gh pr create \
              --title "$pr_title" \
              --body-file pr_body.txt \
              --base main \
              --head ${{ env.branch_name }})
          
            pr_number=$(echo "$pr_url" | grep -o '[0-9]*

  create-release:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if this is a release merge
        id: check-release
        run: |
          latest_commit_message=$(git log -1 --pretty=format:"%s")
          if [[ "$latest_commit_message" =~ ^chore:\ prepare\ release\ v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            version=$(echo "$latest_commit_message" | sed 's/chore: prepare release v//')
            echo "is_release=true" >> $GITHUB_OUTPUT
            echo "version=$version" >> $GITHUB_OUTPUT
            echo "Detected release commit for version $version"
          else
            echo "is_release=false" >> $GITHUB_OUTPUT
            echo "Not a release commit"
          fi

      - name: Setup Go
        if: steps.check-release.outputs.is_release == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Run tests
        if: steps.check-release.outputs.is_release == 'true'
        run: |
          go mod download
          go test ./...

      - name: Build binaries
        if: steps.check-release.outputs.is_release == 'true'
        run: |
          mkdir -p dist
          
          GOOS=linux GOARCH=amd64 go build -o dist/frank-go-sdk-linux-amd64 ./...
          GOOS=darwin GOARCH=amd64 go build -o dist/frank-go-sdk-darwin-amd64 ./...
          GOOS=windows GOARCH=amd64 go build -o dist/frank-go-sdk-windows-amd64.exe ./...

      - name: Extract changelog for release
        if: steps.check-release.outputs.is_release == 'true'
        run: |
          version="${{ steps.check-release.outputs.version }}"
          
          if [ -f CHANGELOG.md ]; then
            awk "/^# Changelog for v$version/,/^# Changelog for v[0-9]/ {if (!/^# Changelog for v[0-9]/ || /^# Changelog for v$version/) print}" CHANGELOG.md > release_notes.md
          
            if [ -s release_notes.md ]; then
              tail -n +2 release_notes.md > release_notes_cleaned.md
          
              if tail -n 1 release_notes_cleaned.md | grep -q "^# Changelog for v"; then
                head -n -1 release_notes_cleaned.md > release_notes_final.md
              else
                mv release_notes_cleaned.md release_notes_final.md
              fi
            else
              echo "## Release v$version" > release_notes_final.md
              echo "" >> release_notes_final.md
              echo "Automated release with latest changes." >> release_notes_final.md
            fi
          
            echo "Release notes extracted for version $version"
          else
            echo "No changelog found, creating basic release notes"
            echo "## Release v$version" > release_notes_final.md
            echo "" >> release_notes_final.md
            echo "Automated release with latest changes." >> release_notes_final.md
          fi

      - name: Create GitHub Release
        if: steps.check-release.outputs.is_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.check-release.outputs.version }}
          name: Release v${{ steps.check-release.outputs.version }}
          body_path: release_notes_final.md
          files: |
            dist/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Clean up release branch
        if: steps.check-release.outputs.is_release == 'true'
        run: |
          version="${{ steps.check-release.outputs.version }}"
          branch_name="release/v$version"
          
          if git show-ref --verify --quiet refs/remotes/origin/$branch_name; then
            git push origin --delete $branch_name || echo "Branch already deleted"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  )
  gh pr edit $pr_number --add-label "release"

echo "Created release PR: $pr_url"
  fi
  
  rm -f pr_body.txt
env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

create-release:
  runs-on: ubuntu-latest
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check if this is a release merge
      id: check-release
      run: |
        latest_commit_message=$(git log -1 --pretty=format:"%s")
        if [[ "$latest_commit_message" =~ ^chore:\ prepare\ release\ v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          version=$(echo "$latest_commit_message" | sed 's/chore: prepare release v//')
          echo "is_release=true" >> $GITHUB_OUTPUT
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "Detected release commit for version $version"
        else
          echo "is_release=false" >> $GITHUB_OUTPUT
          echo "Not a release commit"
        fi

    - name: Setup Go
      if: steps.check-release.outputs.is_release == 'true'
      uses: actions/setup-go@v5
      with:
        go-version: '1.23'

    - name: Run tests
      if: steps.check-release.outputs.is_release == 'true'
      run: |
        go mod download
        go test ./...

    - name: Build binaries
      if: steps.check-release.outputs.is_release == 'true'
      run: |
        mkdir -p dist
        
        GOOS=linux GOARCH=amd64 go build -o dist/frank-go-sdk-linux-amd64 ./...
        GOOS=darwin GOARCH=amd64 go build -o dist/frank-go-sdk-darwin-amd64 ./...
        GOOS=windows GOARCH=amd64 go build -o dist/frank-go-sdk-windows-amd64.exe ./...

    - name: Extract changelog for release
      if: steps.check-release.outputs.is_release == 'true'
      run: |
        version="${{ steps.check-release.outputs.version }}"
        
        if [ -f CHANGELOG.md ]; then
          awk "/^# Changelog for v$version/,/^# Changelog for v[0-9]/ {if (!/^# Changelog for v[0-9]/ || /^# Changelog for v$version/) print}" CHANGELOG.md > release_notes.md
        
          if [ -s release_notes.md ]; then
            tail -n +2 release_notes.md > release_notes_cleaned.md
        
            if tail -n 1 release_notes_cleaned.md | grep -q "^# Changelog for v"; then
              head -n -1 release_notes_cleaned.md > release_notes_final.md
            else
              mv release_notes_cleaned.md release_notes_final.md
            fi
          else
            echo "## Release v$version" > release_notes_final.md
            echo "" >> release_notes_final.md
            echo "Automated release with latest changes." >> release_notes_final.md
          fi
        
          echo "Release notes extracted for version $version"
        else
          echo "No changelog found, creating basic release notes"
          echo "## Release v$version" > release_notes_final.md
          echo "" >> release_notes_final.md
          echo "Automated release with latest changes." >> release_notes_final.md
        fi

    - name: Create GitHub Release
      if: steps.check-release.outputs.is_release == 'true'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ steps.check-release.outputs.version }}
        name: Release v${{ steps.check-release.outputs.version }}
        body_path: release_notes_final.md
        files: |
          dist/*
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Clean up release branch
      if: steps.check-release.outputs.is_release == 'true'
      run: |
        version="${{ steps.check-release.outputs.version }}"
        branch_name="release/v$version"
        
        if git show-ref --verify --quiet refs/remotes/origin/$branch_name; then
          git push origin --delete $branch_name || echo "Branch already deleted"
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}